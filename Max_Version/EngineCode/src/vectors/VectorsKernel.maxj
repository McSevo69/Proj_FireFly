package vectors;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;

class VectorsKernel extends Kernel {

	static final DFEType dataType=dfeInt(8);

	/*DFEVar[] getNeighbors(DFEVar binaryImage, DFEVar x, DFEVar y, int width, int height, DFEVar radius, int maxRadius) {
		int neighSize = width*width;

		DFEVar[] neighbors = new DFEVar[neighSize];

		int centeredIdx = (neighSize-1)/2;

		for (int i=0; i<neighSize; ++i) {
			neighbors[i] = constant.var(dataType, 0);
		}

		//neighbors[centeredIdx] = constant.var(dataType, 0); //can be zero since center cell isn't counted as neighbor

		/cross around center cell -> 4*r
		for (int i=1; i <= maxRadius; ++i) {
			neighbors[centeredIdx-i*width] = ((y - i) < 0 & i <= radius) ? constant.var(dataType, 1) 
					: stream.offset(binaryImage, -i*width); //above
			neighbors[centeredIdx+i*width] = ((y + i) >= height & i <= radius) ? constant.var(dataType, 1)
					: stream.offset(binaryImage, +i*width); //below
			neighbors[centeredIdx-i] = ((x - i) < 0 & i <= radius) ? constant.var(dataType, 1)
					: stream.offset(binaryImage, -i); //left
			neighbors[centeredIdx+i] = ((x + i) >= width & i <= radius) ? constant.var(dataType, 1)
					: stream.offset(binaryImage, +i); // right
		}

		//squares around x -> 4*r^2
		for (int i = 1; i <= maxRadius; ++i) {
			for (int j = 1; j <= maxRadius; ++j) {
				neighbors[centeredIdx-i*width-j] = ((y - i) < 0 | (x - j) < 0 & i <= radius & j <= radius) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,-i*width-j); //above left

				neighbors[centeredIdx-i*width+j] = ((y - i) < 0 | (x + j) >= width & i <= radius & j <= radius) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,-i*width+j); //above right

				neighbors[centeredIdx+i*width-j] = ((y + i) >= height | (x - j) < 0 & i <= radius & j <= radius) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,+i*width-j); //below left

				neighbors[centeredIdx+i*width+j] = ((y + i) >= height | (x + j) >= width & i <= radius & j <= radius) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,+i*width+j); //below right
			}
		}

		return neighbors;
	}*/

	DFEVar getWindResult(DFEVar streamIn, int width, int height, DFEVar x, DFEVar y, DFEVar radius, int maxRadius, int windDir) {
		int moveUpDown = (int) Math.pow(-1, (windDir & 8) >> 3) * ((windDir >> 2) & 1);
		int moveLeftRight = (int) Math.pow(-1, (windDir & 3) >> 1) * (windDir & 1);

		int centerCell = (width*width-1)/2;

		DFEVar cnt = constant.var(dataType, 0);

		if (windDir % 2 == 0) { //vertical
			for (int i = 2; i <= maxRadius; i++) cnt += (stream.offset(streamIn, +moveUpDown*i*width) < -1) ? constant.var(dataType, 1) : 0;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					cnt += (stream.offset(streamIn, +moveUpDown*a*width+b) < -1) ? constant.var(dataType, 1) : 0; //counting left/right ones
					cnt += (stream.offset(streamIn, +moveUpDown*a*width-b) < -1) ? constant.var(dataType, 1) : 0;
				}
			}
		} else if (windDir % 8 <= 3) { //horizontal
			for (int i = 2; i <= maxRadius; ++i) cnt += (stream.offset(streamIn, +moveLeftRight*i) < -1) ? constant.var(dataType, 1) : 0;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					cnt += (stream.offset(streamIn, +moveLeftRight*a+b*width) < -1) ? constant.var(dataType, 1) : 0; //counting above/below ones
					cnt += (stream.offset(streamIn, +moveLeftRight*a-b*width) < -1) ? constant.var(dataType, 1) : 0;
				}
			}
		} else {
			for (int i = 2; i <= maxRadius; ++i) cnt += (stream.offset(streamIn, +moveUpDown*i*width+moveLeftRight*i) < -1) ? constant.var(dataType, 1) : 0; //diagonal

			int diagIdx;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					diagIdx = moveUpDown*a*width+moveLeftRight*a;
					cnt += (stream.offset(streamIn, diagIdx+(-1)*moveUpDown*b*width) < -1) ? constant.var(dataType, 1) : 0; //times (-1) as we go in the opposite direction
					cnt += (stream.offset(streamIn, diagIdx+(-1)*moveLeftRight*b) < -1) ? constant.var(dataType, 1) : 0;
				}
			}
		}
		return cnt;
	}

	DFEVar willBurnDueToWind(DFEVar streamIn, DFEVar x, DFEVar y, int width, int height, DFEVar wind, DFEVar radius, int maxRadius) {
		
		//this is like transforming DFEVar to int
		return control.mux(wind.cast(dfeUInt(4)), getWindResult(streamIn, width, height, x, y, radius, maxRadius, 0), getWindResult(streamIn, width, height, x, y, radius, maxRadius, 1),
			getWindResult(streamIn, width, height, x, y, radius, maxRadius, 2), getWindResult(streamIn, width, height, x, y, radius, maxRadius, 3),
			getWindResult(streamIn, width, height, x, y, radius, maxRadius, 4), getWindResult(streamIn, width, height, x, y, radius, maxRadius, 5),
			getWindResult(streamIn, width, height, x, y, radius, maxRadius, 6), getWindResult(streamIn, width, height, x, y, radius, maxRadius, 7),
			getWindResult(streamIn, width, height, x, y, radius, maxRadius, 8), getWindResult(streamIn, width, height, x, y, radius, maxRadius, 9),
			getWindResult(streamIn, width, height, x, y, radius, maxRadius, 10), getWindResult(streamIn, width, height, x, y, radius, maxRadius, 11),
			getWindResult(streamIn, width, height, x, y, radius, maxRadius, 12), getWindResult(streamIn, width, height, x, y, radius, maxRadius, 13),
			getWindResult(streamIn, width, height, x, y, radius, maxRadius, 14), getWindResult(streamIn, width, height, x, y, radius, maxRadius, 15));		
	}

	DFEVar hasBurningNeighbors(DFEVar streamIn, DFEVar x, DFEVar y, int width, int height, DFEVar wind, DFEVar radius, int maxRadius) {

		DFEVar cnt = (y - 1 >= 0 & stream.offset(streamIn, -width) < -1) ? constant.var(dataType, 1) : constant.var(dataType, 0);
		cnt += (y - 1 >= 0 & x + 1 < width & stream.offset(streamIn, -width + 1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (x + 1 < width & stream.offset(streamIn, +1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y + 1 < height & x + 1 < width & stream.offset(streamIn, +width +1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y + 1 < height & stream.offset(streamIn, +width) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y + 1 < height & x - 1 >= 0 & stream.offset(streamIn, +width -1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (x - 1 >= 0 & stream.offset(streamIn, -1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y - 1 >= 0 & x - 1 >= 0 & stream.offset(streamIn, -width -1) < -1) ? constant.var(dataType, 1) : 0;

		return (cnt > 6) ? constant.var(dataType, -1) : ((cnt > 0 | radius < 2 | (wind & 5) === 0) ? 
			cnt : willBurnDueToWind(streamIn, x, y, width, height, wind, radius, maxRadius));
	}

	DFEVar getNewCellState(DFEVar streamIn, DFEVar x, DFEVar y, int width, int height, DFEVar burning, DFEVar wind, DFEVar radius, int maxRadius) {
		
		DFEVar burnState = hasBurningNeighbors(streamIn, x, y, width, height, wind, radius, maxRadius);

		DFEVar resultDry = (burnState === -1 | burnState > 1) ? burning + 1 : streamIn;
		DFEVar resultNormal = (burnState === -1) ? burning + 1 : (burnState > 1) ? burning -1 : streamIn;

		DFEVar inState = (streamIn > 2) ? constant.var(dfeUInt(2), 0) :
			((streamIn > 0) ? constant.var(dfeUInt(2), 1) : ((streamIn > -1) ? constant.var(dfeUInt(2), 2) : constant.var(dfeUInt(2), 3)));	

		return control.mux(inState, resultDry, resultNormal, streamIn, streamIn + 1);	
	}

	VectorsKernel(KernelParameters parameters, int width, int height, int maxRadius) {
		super(parameters);

		// Input
		DFEVar streamIn = io.input("inData", dataType);

		DFEVar windDir = io.scalarInput("windDir", dataType);
		DFEVar windStrength = io.scalarInput("windStrength", dataType);
		DFEVar burning = io.scalarInput("burningState", dataType);

		//counters
		CounterChain chain = control.count.makeCounterChain();
		DFEVar y_cnt = chain.addCounter(height, 1);
		DFEVar x_cnt = chain.addCounter(width, 1);

		y_cnt = y_cnt.cast(dfeUInt(32));
		x_cnt = x_cnt.cast(dfeUInt(32));

		//Output
		io.output("outData", getNewCellState(streamIn, x_cnt, y_cnt, width, height, burning, windDir, windStrength, maxRadius), dataType);

	}
}
