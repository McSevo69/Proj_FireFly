package vectors;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;

class VectorsKernel extends Kernel {

	static final DFEType dataType=dfeInt(4);

	DFEVar[] getNeighbors(DFEVar binaryImage, DFEVar x, DFEVar y, int width, int height, int radius) {
		int neighSize = (2*radius+1)*(2*radius+1);

		DFEVar[] neighbors = new DFEVar[neighSize];

		int centeredIdx = (neighSize-1)/2;

		neighbors[centeredIdx] = binaryImage; //<-- center cell

		//cross around center cell -> 4*r
		for (int i=1; i <= radius; ++i) {
			neighbors[centeredIdx-i*(2*radius+1)] = ((y - i) < 0) ? constant.var(dataType, 1) //any number higher than $burning is okay here
					: stream.offset(binaryImage, -i*width); //above
			neighbors[centeredIdx+i*(2*radius+1)] = ((y + i) >= height) ? constant.var(dataType, 1)
					: stream.offset(binaryImage,+i*width); //below
			neighbors[centeredIdx-i] = ((x - i) < 0) ? constant.var(dataType, 1)
					: stream.offset(binaryImage,-i); //left
			neighbors[centeredIdx+i] = ((x + i) >= width) ? constant.var(dataType, 1)
					: stream.offset(binaryImage,+i); // right
		}

		//squares around x -> 4*r^2
		for (int i = 1; i <= radius; ++i) {
			for (int j = 1; j <= radius; ++j) {
				neighbors[centeredIdx-i*(2*radius+1)-j] = ((y - i) < 0 || (x - j) < 0) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,-i*width-j); //above left

				neighbors[centeredIdx-i*(2*radius+1)+j] = ((y - i) < 0 || (x + j) >= width) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,-i*width+j); //above right

				neighbors[centeredIdx+i*(2*radius+1)-j] = ((y + i) >= height || (x - j) < 0) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,+i*width-j); //below left

				neighbors[centeredIdx+i*(2*radius+1)+j] = ((y + i) >= height || (x + j) >= width) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,+i*width+j); //below right
			}
		}

		return neighbors;
	}

	DFEVar willBurnDueToWind(DFEVAR streamIn, DFEVar x, DFEVar y, int width, int height, DFEVar wind, DFEVar radius, int maxRadius) {
		
		DFEVar[] neighborhood = getNeighbors(dataset, neighborhood, x, y, width, height, maxRadius);

		int moveUpDown = (int) pow(-1, (wind & 8) >> 3) * ((wind >> 2) & 1);
		int moveLeftRight = (int) pow(-1, (wind & 3) >> 1) * (wind & 1);

		int centerCell = ((2*maxRadius+1)*(2*maxRadius+1)-1)/2;

		DFEVar cnt;

		if (wind % 2 == 0) { //vertical
			for (int i = 2; i <= maxRadius; i++) cnt = (neighborhood[centerCell+moveUpDown*i*(2*radius+1)] < -1 & i <= radius) ? constant.var(dataType, 1) : 0;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					cnt += (neighborhood[centerCell+moveUpDown*a*(2*maxRadius+1)+b] < -1 & a <= radius) ? constant.var(dataType, 1) : 0; //counting left/right ones
					cnt += (neighborhood[centerCell+moveUpDown*a*(2*maxRadius+1)-b] < -1 & a <= radius) ? constant.var(dataType, 1) : 0;
				}
			}
		} else if (wind % 8 <= 3) { //horizontal
			for (int i = 2; i <= maxRadius; ++i) cnt = (neighborhood[centerCell+moveLeftRight*i] < -1 & i <= radius) ? constant.var(dataType, 1) : 0;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					cnt += (neighborhood[centerCell+moveLeftRight*a+b*(2*maxRadius+1)] < -1 & a <= radius) ? constant.var(dataType, 1) : 0; //counting above/below ones
					cnt += (neighborhood[centerCell+moveLeftRight*a-b*(2*maxRadius+1)] < -1 & a <= radius) ? constant.var(dataType, 1) : 0;
				}
			}
		} else {
			for (int i = 2; i <= maxRadius; ++i) cnt = (neighborhood[centerCell+moveUpDown*i*(2*maxRadius+1)+moveLeftRight*i] < -1 & i <= radius) ? constant.var(dataType, 1) : 0; //diagonal

			int diagIdx = 0;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					diagIdx = centerCell+moveUpDown*a*(2*maxRadius+1)+moveLeftRight*a;
					cnt += (neighborhood[diagIdx+(-1)*moveUpDown*b*(2*maxRadius+1)] < -1 & a <= radius) ? constant.var(dataType, 1) : 0; //times (-1) as we go in the opposite direction
					cnt += (neighborhood[diagIdx+(-1)*moveLeftRight*b] < -1 & a <= radius) ? constant.var(dataType, 1) : 0;
				}
			}
		}

		return cnt;
	}

	DFEVar hasBurningNeighbors(DFEVar streamIn, DFEVar x, DFEVar y, int width, int height, DFEVar wind, DFEVar radius, int maxRadius) {

		DFEVar cnt = (y - 1 >= 0) ? (stream.offset(streamIn, -width) < -1) ? constant.var(dataType, 1) : constant.var(dataType, 0);
		cnt += (y - 1 >= 0 & x + 1 < width) ? (stream.offset(streamIn, -width + 1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (x + 1 < width) ? (stream.offset(streamIn, +1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y + 1 < height & x + 1 < width) ? (stream.offset(streamIn, +width +1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y + 1 < height) ? (stream.offset(streamIn, +width) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y + 1 < height & x - 1 >= 0) ? (stream.offset(streamIn, +width -1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (x - 1 >= 0) ? (stream.offset(streamIn, -1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y - 1 >= 0 & x - 1 >= 0) ? (stream.offset(streamIn, -width -1) < -1) ? constant.var(dataType, 1) : 0;

		return (cnt > 6) ? constant.var(dataType, -1) : (cnt > 0 || radius < 2 || (wind & 5) == 0) ? 
			cnt : willBurnDueToWind(streamIn, x, y, width, height, wind, radius, maxRadius);
	}

	DFEVar getNewCellState(DFEVar streamIn, DFEVar x, DFEVar y, int width, int height, int burning, DFEVar wind, DFEVar radius, int maxRadius) {
		
		DFEVar burnState = hasBurningNeighbors(streamIn, x, y, width, height, wind, radius, maxRadius);

		DFEVar resultDry = (burnstate == -1 | burnState > 1) ? burning + 1 : streamIn;
		DFEVar resultNormal = (burnState == -1) ? burning + 1 : (burnState > 1) ? burning -1 : streamIn;

		DFEVar inState = (streamIn > 2) ? constant.var(dfeUInt(2), 0) : (streamIn > 0) ? 1 : (streamIn < -1) ? 2 : 3;	

		return control.mux(inState, resultDry, resultNormal, streamIn + 1, streamIn);	
	}

	VectorsKernel(KernelParameters parameters, int width, int height, int maxRadius, int burning) {
		super(parameters);

		// Input
		DFEVar streamIn = io.input("inData", dataType);

		DFEVar windDir = io.scalarInput("windDir", dataType);
		DFEVar windStrength = io.scalarInput("windStrength", dataType);

		//counters
		CounterChain chain = control.count.makeCounterChain();
		DFEVar y_cnt = chain.addCounter(height, 1);
		DFEVar x_cnt = chain.addCounter(width, 1);

		y_cnt = y_cnt.cast(dfeUInt(32));
		x_cnt = x_cnt.cast(dfeUInt(32));

		//Output
		io.output("outData", getNewCellState(streamIn, x_cnt, y_cnt, width, height, burning, windDir, windStrength, maxRadius), dataType);

	}
}
