package vectors;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;

class VectorsKernel extends Kernel {

	static final DFEType dataType=dfeInt(4);

	DFEVar[] getNeighbors(DFEVar binaryImage, DFEVar x, DFEVar y, int width, int height, int radius) {
		int neighSize = (2*radius+1)*(2*radius+1);

		DFEVar[] neighbors = new DFEVar[neighSize];

		int centeredIdx = (neighSize-1)/2;

		neighbors[centeredIdx] = binaryImage; //<-- center cell

		//cross around center cell -> 4*r
		for (int i=1; i <= radius; ++i) {
			neighbors[centeredIdx-i*(2*radius+1)] = ((y - i) < 0) ? constant.var(dataType, 1) //any number higher than $burning is okay here
					: stream.offset(binaryImage, -i*width); //above
			neighbors[centeredIdx+i*(2*radius+1)] = ((y + i) >= height) ? constant.var(dataType, 1)
					: stream.offset(binaryImage,+i*width); //below
			neighbors[centeredIdx-i] = ((x - i) < 0) ? constant.var(dataType, 1)
					: stream.offset(binaryImage,-i); //left
			neighbors[centeredIdx+i] = ((x + i) >= width) ? constant.var(dataType, 1)
					: stream.offset(binaryImage,+i); // right
		}

		//squares around x -> 4*r^2
		for (int i = 1; i <= radius; ++i) {
			for (int j = 1; j <= radius; ++j) {
				neighbors[centeredIdx-i*(2*radius+1)-j] = ((y - i) < 0 | (x - j) < 0) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,-i*width-j); //above left

				neighbors[centeredIdx-i*(2*radius+1)+j] = ((y - i) < 0 | (x + j) >= width) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,-i*width+j); //above right

				neighbors[centeredIdx+i*(2*radius+1)-j] = ((y + i) >= height | (x - j) < 0) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,+i*width-j); //below left

				neighbors[centeredIdx+i*(2*radius+1)+j] = ((y + i) >= height | (x + j) >= width) ? constant.var(dataType, 1) :
					stream.offset(binaryImage,+i*width+j); //below right
			}
		}

		return neighbors;
	}

	DFEVar getWindResult(DFEVar[] neighborhood, DFEVar radius, int maxRadius, int windDir) {
		int moveUpDown = (int) Math.pow(-1, (windDir & 8) >> 3) * ((windDir >> 2) & 1);
		int moveLeftRight = (int) Math.pow(-1, (windDir & 3) >> 1) * (windDir & 1);

		int centerCell = ((2*maxRadius+1)*(2*maxRadius+1)-1)/2;

		DFEVar cnt = constant.var(dataType, 0);

		if (windDir % 2 == 0) { //vertical
			for (int i = 2; i <= maxRadius; i++) cnt += (neighborhood[centerCell+moveUpDown*i*(2*maxRadius+1)] < -1 & i <= radius) ? constant.var(dataType, 1) : 0;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					cnt += (neighborhood[centerCell+moveUpDown*a*(2*maxRadius+1)+b] < -1 & a <= radius) ? constant.var(dataType, 1) : 0; //counting left/right ones
					cnt += (neighborhood[centerCell+moveUpDown*a*(2*maxRadius+1)-b] < -1 & a <= radius) ? constant.var(dataType, 1) : 0;
				}
			}
		} else if (windDir % 8 <= 3) { //horizontal
			for (int i = 2; i <= maxRadius; ++i) cnt += (neighborhood[centerCell+moveLeftRight*i] < -1 & i <= radius) ? constant.var(dataType, 1) : 0;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					cnt += (neighborhood[centerCell+moveLeftRight*a+b*(2*maxRadius+1)] < -1 & a <= radius) ? constant.var(dataType, 1) : 0; //counting above/below ones
					cnt += (neighborhood[centerCell+moveLeftRight*a-b*(2*maxRadius+1)] < -1 & a <= radius) ? constant.var(dataType, 1) : 0;
				}
			}
		} else {
			for (int i = 2; i <= maxRadius; ++i) cnt += (neighborhood[centerCell+moveUpDown*i*(2*maxRadius+1)+moveLeftRight*i] < -1 & i <= radius) ? constant.var(dataType, 1) : 0; //diagonal

			int diagIdx;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					diagIdx = centerCell+moveUpDown*a*(2*maxRadius+1)+moveLeftRight*a;
					cnt += (neighborhood[diagIdx+(-1)*moveUpDown*b*(2*maxRadius+1)] < -1 & a <= radius) ? constant.var(dataType, 1) : 0; //times (-1) as we go in the opposite direction
					cnt += (neighborhood[diagIdx+(-1)*moveLeftRight*b] < -1 & a <= radius) ? constant.var(dataType, 1) : 0;
				}
			}
		}

		return cnt;

	}

	DFEVar willBurnDueToWind(DFEVar streamIn, DFEVar x, DFEVar y, int width, int height, DFEVar wind, DFEVar radius, int maxRadius) {
		
		DFEVar[] neighborhood = getNeighbors(streamIn, x, y, width, height, maxRadius);

		return control.mux(wind.cast(dfeUInt(4)), getWindResult(neighborhood, radius, maxRadius, 0), getWindResult(neighborhood, radius, maxRadius, 1),
			getWindResult(neighborhood, radius, maxRadius, 2), getWindResult(neighborhood, radius, maxRadius, 3),
			getWindResult(neighborhood, radius, maxRadius, 4), getWindResult(neighborhood, radius, maxRadius, 5),
			getWindResult(neighborhood, radius, maxRadius, 6), getWindResult(neighborhood, radius, maxRadius, 7),
			getWindResult(neighborhood, radius, maxRadius, 8), getWindResult(neighborhood, radius, maxRadius, 9),
			getWindResult(neighborhood, radius, maxRadius, 10), getWindResult(neighborhood, radius, maxRadius, 11),
			getWindResult(neighborhood, radius, maxRadius, 12), getWindResult(neighborhood, radius, maxRadius, 13),
			getWindResult(neighborhood, radius, maxRadius, 14), getWindResult(neighborhood, radius, maxRadius, 15));		
	}

	DFEVar hasBurningNeighbors(DFEVar streamIn, DFEVar x, DFEVar y, int width, int height, DFEVar wind, DFEVar radius, int maxRadius) {

		DFEVar cnt = (y - 1 >= 0 & stream.offset(streamIn, -width) < -1) ? constant.var(dataType, 1) : constant.var(dataType, 0);
		cnt += (y - 1 >= 0 & x + 1 < width & stream.offset(streamIn, -width + 1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (x + 1 < width & stream.offset(streamIn, +1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y + 1 < height & x + 1 < width & stream.offset(streamIn, +width +1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y + 1 < height & stream.offset(streamIn, +width) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y + 1 < height & x - 1 >= 0 & stream.offset(streamIn, +width -1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (x - 1 >= 0 & stream.offset(streamIn, -1) < -1) ? constant.var(dataType, 1) : 0;
		cnt += (y - 1 >= 0 & x - 1 >= 0 & stream.offset(streamIn, -width -1) < -1) ? constant.var(dataType, 1) : 0;

		return (cnt > 6) ? constant.var(dataType, -1) : (cnt > 0 | radius < 2 | (wind & 5) === 0) ? 
			cnt : willBurnDueToWind(streamIn, x, y, width, height, wind, radius, maxRadius);
	}

	DFEVar getNewCellState(DFEVar streamIn, DFEVar x, DFEVar y, int width, int height, int burning, DFEVar wind, DFEVar radius, int maxRadius) {
		
		DFEVar burnState = hasBurningNeighbors(streamIn, x, y, width, height, wind, radius, maxRadius);

		DFEVar resultDry = (burnState === -1 | burnState > 1) ? burning + 1 : streamIn;
		DFEVar resultNormal = (burnState === -1) ? burning + 1 : (burnState > 1) ? burning -1 : streamIn;

		DFEVar inState = (streamIn > 2) ? constant.var(dfeUInt(2), 0) :
			((streamIn > 0) ? constant.var(dfeUInt(2), 1) : (streamIn < -1) ? constant.var(dfeUInt(2), 2) : constant.var(dfeUInt(2), 3));	

		return control.mux(inState, resultDry, resultNormal, streamIn + 1, streamIn);	
	}

	VectorsKernel(KernelParameters parameters, int width, int height, int maxRadius, int burning) {
		super(parameters);

		// Input
		DFEVar streamIn = io.input("inData", dataType);

		DFEVar windDir = io.scalarInput("windDir", dataType);
		DFEVar windStrength = io.scalarInput("windStrength", dataType);

		//counters
		CounterChain chain = control.count.makeCounterChain();
		DFEVar y_cnt = chain.addCounter(height, 1);
		DFEVar x_cnt = chain.addCounter(width, 1);

		y_cnt = y_cnt.cast(dfeUInt(32));
		x_cnt = x_cnt.cast(dfeUInt(32));

		//Output
		io.output("outData", getNewCellState(streamIn, x_cnt, y_cnt, width, height, burning, windDir, windStrength, maxRadius), dataType);

	}
}
