package vectors;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Params;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;

class VectorsKernel extends Kernel {

	static final DFEType dataType=dfeInt(8);

	DFEVar[] getNeighbors(Memory<DFEVar> reverseRam, DFEVar x, DFEVar y, int width, int height, DFEVar radius, int maxRadius) {
		int neighWidth = (2*maxRadius+1);
		int neighSize = neighWidth*neighWidth;

		DFEVar[] neighbors = new DFEVar[neighSize];

		int centeredIdx = (neighSize-1)/2;

		neighbors[centeredIdx] = constant.var(dataType, 1);

		int addrBits = MathUtils.bitsToAddress(width*height);
		DFEVar idx = y*width+x;
		idx = idx.cast(dfeUInt(addrBits));

		//cross around center cell -> 4*r
		for (int i=1; i <= maxRadius; ++i) {
			neighbors[centeredIdx-i*neighWidth] = ((y - i) < 0 | i > radius) ? constant.var(dataType, 1) 
					: reverseRam.read(idx -i*width); //above
			neighbors[centeredIdx+i*neighWidth] = ((y + i) >= height | i > radius) ? constant.var(dataType, 1)
					: reverseRam.read(idx +i*width); //below
			neighbors[centeredIdx-i] = ((x - i) < 0 | i > radius) ? constant.var(dataType, 1)
					: reverseRam.read(idx -i); //left
			neighbors[centeredIdx+i] = ((x + i) >= width | i > radius) ? constant.var(dataType, 1)
					: reverseRam.read(idx +i); // right
		}

		//squares around x -> 4*r^2
		for (int i = 1; i <= maxRadius; ++i) {
			for (int j = 1; j <= maxRadius; ++j) {
				neighbors[centeredIdx-i*neighWidth-j] = ((y - i) < 0 | (x - j) < 0 | i > radius | j > radius) ? constant.var(dataType, 1) :
					reverseRam.read(idx-i*width-j); //above left

				neighbors[centeredIdx-i*neighWidth+j] = ((y - i) < 0 | (x + j) >= width | i > radius | j > radius) ? constant.var(dataType, 1) :
					reverseRam.read(idx-i*width+j); //above right

				neighbors[centeredIdx+i*neighWidth-j] = ((y + i) >= height | (x - j) < 0 | i > radius | j > radius) ? constant.var(dataType, 1) :
					reverseRam.read(idx+i*width-j); //below left

				neighbors[centeredIdx+i*neighWidth+j] = ((y + i) >= height | (x + j) >= width | i > radius | j > radius) ? constant.var(dataType, 1) :
					reverseRam.read(idx+i*width+j); //below right
			}
		}
		return neighbors;
	}

	DFEVar getWindResult(DFEVar[] neighborhood, DFEVar x, DFEVar y, DFEVar radius, int maxRadius, int windDir) {
		int moveUpDown = (int) Math.pow(-1, (windDir & 8) >> 3) * ((windDir >> 2) & 1);
		int moveLeftRight = (int) Math.pow(-1, (windDir & 3) >> 1) * (windDir & 1);

		int centerCell = ((2*maxRadius+1)*(2*maxRadius+1)-1)/2;
		
		DFEVar cnt = constant.var(dataType, 0);		

		if (windDir % 2 == 0) { //vertical
			for (int i = 2; i <= maxRadius; i++)
				cnt += (neighborhood[centerCell+moveUpDown*i*(2*maxRadius+1)] < -1) ? constant.var(dataType, 1) : 0;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					cnt += (neighborhood[centerCell+moveUpDown*a*(2*maxRadius+1)+b] < -1) ? constant.var(dataType, 1) : 0; //counting left/right ones
					cnt += (neighborhood[centerCell+moveUpDown*a*(2*maxRadius+1)-b] < -1) ? constant.var(dataType, 1) : 0;
				}
			}
		} else if (windDir % 8 <= 3) { //horizontal
			for (int i = 2; i <= maxRadius; ++i)
				cnt += (neighborhood[centerCell+moveLeftRight*i] < -1) ? constant.var(dataType, 1) : 0;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					cnt += (neighborhood[centerCell+moveLeftRight*a+b*(2*maxRadius+1)] < -1) ? constant.var(dataType, 1) : 0; //counting above/below ones
					cnt += (neighborhood[centerCell+moveLeftRight*a-b*(2*maxRadius+1)] < -1) ? constant.var(dataType, 1) : 0;
				}
			}
		} else {
			for (int i = 2; i <= maxRadius; ++i)
				cnt += (neighborhood[centerCell+moveUpDown*i*(2*maxRadius+1)+moveLeftRight*i] < -1) ? constant.var(dataType, 1) : 0; //diagonal

			int diagIdx;

			for (int a = 2; a <= maxRadius; ++a) {
				for (int b = 1; b < a; ++b) {
					diagIdx = centerCell+moveUpDown*a*(2*maxRadius+1)+moveLeftRight*a;
					cnt += (neighborhood[diagIdx+(-1)*moveUpDown*b*(2*maxRadius+1)] < -1) ? constant.var(dataType, 1) : 0; //times (-1) as we go in the opposite direction
					cnt += (neighborhood[diagIdx+(-1)*moveLeftRight*b] < -1) ? constant.var(dataType, 1) : 0;
				}
			}
		}
		return cnt;
	}

	DFEVar willBurnDueToWind(DFEVar[] neighborhood, DFEVar x, DFEVar y, int width, int height, DFEVar wind, DFEVar radius, int maxRadius) {
		
		//this is like transforming DFEVar to int
		return control.mux(wind.cast(dfeUInt(4)), getWindResult(neighborhood, x, y, radius, maxRadius, 0), getWindResult(neighborhood, x, y, radius, maxRadius, 1),
			getWindResult(neighborhood, x, y, radius, maxRadius, 2), getWindResult(neighborhood, x, y, radius, maxRadius, 3),
			getWindResult(neighborhood, x, y, radius, maxRadius, 4), getWindResult(neighborhood, x, y, radius, maxRadius, 5),
			getWindResult(neighborhood, x, y, radius, maxRadius, 6), getWindResult(neighborhood, x, y, radius, maxRadius, 7),
			getWindResult(neighborhood, x, y, radius, maxRadius, 8), getWindResult(neighborhood, x, y, radius, maxRadius, 9),
			getWindResult(neighborhood, x, y, radius, maxRadius, 10), getWindResult(neighborhood, x, y, radius, maxRadius, 11),
			getWindResult(neighborhood, x, y, radius, maxRadius, 12), getWindResult(neighborhood, x, y, radius, maxRadius, 13),
			getWindResult(neighborhood, x, y, radius, maxRadius, 14), getWindResult(neighborhood, x, y, radius, maxRadius, 15));		
	}

	DFEVar hasBurningNeighbors(Memory<DFEVar> reverseRam, DFEVar x, DFEVar y, int width, int height, DFEVar wind, DFEVar radius, int maxRadius) {

		DFEVar neighborhood[] = getNeighbors(reverseRam, x, y, width, height, radius, maxRadius);

		int neighWidth = (2*maxRadius+1);
		int centerCell = (neighWidth*neighWidth-1)/2;

		DFEVar cnt = (neighborhood[centerCell-neighWidth] < -1) ? constant.var(dataType, 1) : 0;
		cnt += (neighborhood[centerCell-neighWidth+1] < -1) ? constant.var(dataType, 1) : 0;
		cnt += (neighborhood[centerCell+1] < -1) ? constant.var(dataType, 1) : 0;
		cnt += (neighborhood[centerCell+neighWidth+1] < -1) ? constant.var(dataType, 1) : 0;
		cnt += (neighborhood[centerCell+neighWidth] < -1) ? constant.var(dataType, 1) : 0;
		cnt += (neighborhood[centerCell+neighWidth-1] < -1) ? constant.var(dataType, 1) : 0;
		cnt += (neighborhood[centerCell-1] < -1) ? constant.var(dataType, 1) : 0;
		cnt += (neighborhood[centerCell-neighWidth-1] < -1) ? constant.var(dataType, 1) : 0;

		return (cnt > 6) ? constant.var(dataType, -1) : ((cnt > 0 | radius < 2 | (wind & 5) === 0) ? 
			cnt : willBurnDueToWind(neighborhood, x, y, width, height, wind, radius, maxRadius));
	}

	DFEVar getNewCellState(Memory<DFEVar> reverseRam, DFEVar x, DFEVar y, int width, int height, DFEVar burning, DFEVar wind, DFEVar radius, int maxRadius) {
		
		int addrBits = MathUtils.bitsToAddress(width*height);
		DFEVar idx = y*width+x;
		idx = idx.cast(dfeUInt(addrBits));

		DFEVar streamIn = reverseRam.read(idx);

		DFEVar burnState = hasBurningNeighbors(reverseRam, x, y, width, height, wind, radius, maxRadius);

		DFEVar resultDry = (burnState === -1 | burnState > 0) ? burning + 1 : streamIn;
		DFEVar resultNormal = (burnState === -1) ? burning + 1 : ((burnState > 1) ? burning -1 : streamIn);		

		DFEVar inState = (streamIn > 2) ? constant.var(dfeUInt(2), 0) :
			((streamIn > 0) ? constant.var(dfeUInt(2), 1) : ((streamIn > -1) ? constant.var(dfeUInt(2), 2) : constant.var(dfeUInt(2), 3)));	

		return control.mux(inState, resultDry, resultNormal, streamIn, streamIn + 1);	
	}

	VectorsKernel(KernelParameters parameters, int width, int height, int maxRadius) {
		super(parameters);

		int addrBits = MathUtils.bitsToAddress(width*height);
		Params addressCounterParams = control.count.makeParams(addrBits+1).withWrapMode(WrapMode.STOP_AT_MAX);
		Counter addressCounter = control.count.makeCounter(addressCounterParams);

		DFEVar readingInput = addressCounter.getCount() < width*height;

		// Input
		DFEVar streamIn = io.input("inData", dataType, readingInput);

		DFEVar windDir = io.scalarInput("windDir", dataType);
		DFEVar windStrength = io.scalarInput("windStrength", dataType);
		DFEVar burning = io.scalarInput("burningState", dataType);

		// Counters
		Params paramsOne = control.count.makeParams(addrBitsWidth)
		.withEnable(~readingInput)
		.withMax(width);

		Counter counterOne = control.count.makeCounter(paramsOne);
		
		Params paramsTwo = control.count.makeParams(addrBitsHeight)
		.withEnable(counterOne.getWrap())
		.withMax(height);

		Counter counterTwo = control.count.makeCounter(paramsTwo);

		DFEVar y_cnt = counterTwo.getCount().cast(dfeUInt(32));		
		DFEVar x_cnt = counterOne.getCount().cast(dfeUInt(32)); 

		Memory<DFEVar> reverseRam = mem.alloc(dataType, width*height);

		reverseRam.write(addressCounter.getCount().cast(dfeUInt(addrBits)), streamIn, readingInput);

		//Output
		io.output("outData", getNewCellState(reverseRam, x_cnt, y_cnt, width, height, burning, windDir, windStrength, maxRadius), dataType, ~readingInput);

	}
}
